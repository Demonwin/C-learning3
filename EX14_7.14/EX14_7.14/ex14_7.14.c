#define  _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>

struct Test    // 这里已知结构体的大小是20个字节
{
	int NUM;
	char* pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}* p;
  
//假设 p 的值为0x100000.

int main()
{
	printf("%p\n", p + 0x1);  // 0x100014 -  因为结构体大小是20个字节，所以这里 +0x1 就相当于加上20，即转换为16进制0x000014
	
	printf("%p\n", (unsigned long)p + 0x1);//0x100001 - 因为p被强制类型转换为long，所以 +0x1就是+0x000001
	
	printf("%p\n", (unsigned int*)p + 0x1);//0x100004 - 因为p被强制转换为int* 类型，所以+0x1 就相当于 +0x000004
	return 0;
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

//int main()
//{
//	int a[] = { 1,2,3,4,5 };
//	int* par = (int*)(&a + 1);
//	printf("%d  %d\n", *(a + 1), *(par - 1));
//	return 0;
//}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

//int main()
//{
//	int a[3][4] = { 0 };//  二维数组 
//
//	printf("%d\n", sizeof(a));//48 - 3*4 * sizeof(int)
//
//	printf("%d\n", sizeof(a[0][0]));//4
//
//	printf("%d\n", sizeof(a[0]));//16 - a[0]可以理解为二维数组中的第一行的数组名
//
//	printf("%d\n", sizeof(a[0] + 1));//4 - a[0]+1 可以理解为是第一行的第二个元素的地址
//
//	printf("%d\n", sizeof(*(a[0] + 1)));//4
//
//	printf("%d\n", sizeof(a + 1));//4 - 对于二维数组来说，首元素就是第一行的地址，地址的大小就是4/8个字节
//
//	printf("%d\n", sizeof(*(a + 1)));//16 
//
//	printf("%d\n", sizeof(&a[0] + 1));//4 - (&a[0]+1)表示第二行的地址，而地址的大小就是4/8个字节
//
//	printf("%d\n", sizeof(*(&a[0]+1)));//16 - 对第二行的地址解引用，得到第二行的所有元素
//
//	printf("%d\n", sizeof(*a));//16 - a作为二维数组的数组名，表示首元素的地址，也就是第一行的地址 
//
//	printf("%d\n", sizeof(a[3]));//16 - 虽然这个二维数组没有第四行，但是这里sizeof没有真正访问到第四行
//	                            // 所以即使不存在，也能通过类型计算大小的
//	
//	printf("%d\n", sizeof(a[-1]));// 所以这里的结果也是16
//	
//	return 0;
//}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

//int main()
//{
//	char* p = "abcdef";
//
//	printf("%d\n", strlen(p));// 6
//
//	printf("%d\n", strlen(p + 1));//5 - p+1表示第二个元素的地址，所以得从第二个元素 b 开始算直到遇到\0
//
//	printf("%d\n", strlen(*p));// 代码错误
//
//	printf("%d\n", strlen(p[0]));//代码错误
//
//	printf("%d\n", strlen(&p));//随机值 - 因为p相当于地址，地址的地址取出来 是什么是不能确定的
//
//	printf("%d\n", strlen(&p + 1));//随机值，且与上面的随机值没有关联
//
//	printf("%d\n", strlen(&p[0] + 1));//5
//
//	return 0;
//}


//――――――――――――――――――――――――――――――――――――――――――――――――――――――――

//int main()
//{
//	char* p = "abcdef";
//
//	printf("%d\n", sizeof(p));// 4 - p是一个指针，相当于地址，地址的大小就是4/8个字节
//
//	printf("%d\n", sizeof(p + 1));//4 - p+1 还是一个地址，地址的大小就是4/8个字节
//
//	printf("%d\n", sizeof(*p));// 1 - p表示首元素地址，*p就是去除首元素a，所以char类型的就只有1个字节
//
//	printf("%d\n", sizeof(p[0]));//1 - p[0] 等价于 *（p+0），取出的还是首元素a 
//
//	printf("%d\n", sizeof(&p));//4 - 地址，地址的大小就是4/8个字节
//
//	printf("%d\n", sizeof(&p + 1));//4
//
//	printf("%d\n", sizeof(&p[0] + 1));//4
//
//	return 0;
//}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

//int main()
//{
//	char arr[] = "abcdef";
//	printf("%d\n", strlen(arr)); // 6 - strlen 遇到最后的\0就停止（但不包括）
//
//	printf("%d\n", strlen(arr + 0));//6 
//
//	printf("%d\n", strlen(*arr));//strlen需要接受的是一个地址，因此这里代码错误，无法运行
//
//	printf("%d\n", strlen(arr[1]));// 同上题
//
//	printf("%d\n", strlen(&arr)); //6 - &arr 表示整个数组的地址，但仍然是从首元素地址开始
//
//	printf("%d\n", strlen(&arr + 1));//随机值 -  &arr+1 表示跳过整个数组的地址开始算（当然\0也跳过去了）
//
//	printf("%d\n", strlen(&arr[0]) + 1);//5 - 表示从第二个元素 b 的地址开始
//
//	return 0;
//}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

//int main()
//{
//	char arr[] = "abcdef";   // 这里放了一个字符串，因此后面会默认放一个 \0，所以一共有7个字符（\0算一个字符）
//	 
//	printf("%d\n", sizeof(arr));//  7
//
//	printf("%d\n", sizeof(arr + 0)); //4 - arr+0 表示首元素地址+0，还是首元素地址，地址的大小就是4/8个字节
//
//	printf("%d\n", sizeof(*arr));// 1 - *arr表示的就是首个元素
//
//	printf("%d\n", sizeof(arr[1]));// 1 - arr[1]表示的是第二个元素
//
//	printf("%d\n", sizeof(&arr));// 4/8
//
//	printf("%d\n", sizeof(&arr + 1));// 4/8
//
//	printf("%d\n", sizeof(&arr[0] + 1));// 4/8
//
//	return 0;
//}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

//int main() // strlen 是求字符串长度的，而sizeof是求所占空间大小的
//{
//	char arr[] = { 'a','b','c','d','e','f' };
//
//	printf("%d\n", strlen(arr));// 随机值 - arr这里表示首元素地址， 因为strlen是要找到 \0 才能停止，而该字符没有出现\0
//
//	printf("%d\n", strlen(arr + 0));// 随机值 - 这道题的写法其实就等于上一题的
//
//	printf("%d\n", strlen(*arr));// 错误代码，不能运行 - 因为*arr表示第一个元素'a'，但strlen需要的是传入地址，a ->97,所以非法访问地址了
//
//	printf("%d\n", strlen(arr[1]));// 错误代码，不能运行 - arr[1]表示第二个元素'b'。。。
//
//	printf("%d\n", strlen(&arr)); //  随机值 - 
//
//	printf("%d\n", strlen(&arr + 1));// 随机值 - 与上一个随机值相差6
//
//	printf("%d\n", strlen(&arr[0] + 1));// 随机值 - 遇上一个相差1
//
//	return 0;
//}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

//int main()
//{
//	//一个字符数组，有6个元素，每个元素是一个字符
//	char arr[] = { 'a','b','c','d','e','f' };
//	printf("%d\n",sizeof(arr));//6 - sizeof计算的是数组大小，6*1=6
//
//	printf("%d\n", sizeof(arr + 0));//4 - arr是首元素的地址，arr+0也是首元素的地址，是地址那它的大小就是4/8个字节（不要以为是字符数组答案就是1）
//
//	printf("%d\n", sizeof(*arr)); //1 - *arr表示的是首元素，而首元素是一个字符，一个字符的大小当然是1个字节
//
//	printf("%d\n",sizeof(arr[1]));// 这个简单
//
//	printf("%d\n",sizeof(&arr)); // 类似于下面的题
//
//	printf("%d\n", sizeof(&arr + 1));// 类似于下面的题
//
//	printf("%d\n", sizeof(&arr[0] + 1));//类似于下面的题
//
//	return 0;
//}

//――――――――――――――――――――――――――――――――――――――――――――――

//int main()
//{
//	// 数组名是首元素的地址（两个列外）
//	//1. sizeof（数组名） - 数组名表示整个数组
//	//2. &数组名 - 数组名表示整个数组
//
//	//一个整型数组
//	int a[] = { 1,2,3,4 };
//	printf("%d\n", sizeof(a)); // sizeof（数组名）-计算的是数组总的大小-单位是字节-16
//
//	printf("%d\n", sizeof(a+0));// 4 - 数组名这里表示首元素的值，a+0还是首元素的地址，地址的大小就是4/8个字节
//
//	printf("%d\n", sizeof(a+1));// 4 - 数组名这里表示首元素的值，a+1是第二个元素的地址，地址的大小就是4/8个字节
//
//	printf("%d\n", sizeof(*a));//  4 - 数组名表示首元素地址，*a就是首元素，sizeof（*a）就是4
//
//	printf("%d\n", sizeof(a[1]));// 4 - 求的是第二个元素的大小
//
//	printf("%d\n", sizeof(&a));// 4 - &a取出的是数组的地址，但是数组的地址那也是地址，地址的大小就是4/8个字节
//
//	printf("%d\n", sizeof(*&a));// 16 - *&a 就等价于 a,所以它的结果和第一个是一样的
//
//	printf("%d\n", sizeof(&a+1));// 4 - 因为&a 表示取出数组的地址，所以(&a+1)表示跳到过完这个数组地址的地方，但还是地址
//
//	printf("%d\n", sizeof(&a[0]));//4 - &a[0]表示第一个元素的地址
//
//	printf("%d\n", sizeof(&a[0]+1));//4 - &a[0]+1 表示第二个元素的地址
//
//	return 0;
//}